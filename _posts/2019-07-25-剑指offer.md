# 题目和代码来自于[牛客网-剑指offer](https://www.nowcoder.com/ta/coding-interviews)
##题目
**代码的顺序是按照牛客网上的题目顺序来的，具体的题目的类别参照下面的分类和各类中对应题目的序号。实际练习的时候可以按照类别进行练习**
###数据结构类题目

**LinkedList**

003-从尾到头打印链表  
014-链表中倒数第k个结点  
015-反转链表  
016-合并两个或k个有序链表  
025-复杂链表的复制  
036-两个链表的第一个公共结点  
055-链表中环的入口结点  
056-删除链表中重复的结点  


**Tree**

004-重建二叉树  
017-树的子结构  
018-二叉树的镜像
022-从上往下打印二叉树  
023-二叉搜索树的后序遍历序列  
024-二叉树中和为某一值的路径  
026-二叉搜索树与双向链表  
038-二叉树的深度  
039-平衡二叉树  
057-二叉树的下一个结点  
058-对称的二叉树  
059-按之字形顺序打印二叉树  
060-把二叉树打印成多行  
061-序列化二叉树  
062-二叉搜索树的第k个结点  


**Stack & Queue**

005-用两个栈实现队列  
020-包含min函数的栈  
021-栈的压入、弹出序列  
044-翻转单词顺序列(栈)  
064-滑动窗口的最大值(双端队列)  


**Heap**

029-最小的K个数  


**Hash Table**

034-第一个只出现一次的字符  

**图**

065-矩阵中的路径(BFS)  
066-机器人的运动范围(DFS)  

###具体算法类题目

**斐波那契数列**

007-斐波拉契数列  
008-跳台阶  
009-变态跳台阶  
010-矩形覆盖  


**搜索算法**

001-二维数组查找  
006-旋转数组的最小数字（二分查找）  
037-数字在排序数组中出现的次数（二分查找）  


**全排列**

027-字符串的排列


**动态规划**

030-连续子数组的最大和  
052-正则表达式匹配  


**回溯**

065-矩阵中的路径(BFS)  
066-机器人的运动范围(DFS)  


**排序**

035-数组中的逆序对(归并排序)  
029-最小的K个数(堆排序)  
029-最小的K个数(快速排序)  


**位运算**

011-二进制中1的个数  
012-数值的整数次方    
040-数组中只出现一次的数字  


**其他算法**

002-替换空格  
013-调整数组顺序使奇数位于偶数前面  
028-数组中出现次数超过一半的数字  
031-整数中1出现的次数（从1到n整数中1出现的次数）  
032-把数组排成最小的数  
033-丑数  
041-和为S的连续正数序列(滑动窗口思想)  
042-和为S的两个数字(双指针思想)  
043-左旋转字符串(矩阵翻转)  
046-孩子们的游戏-圆圈中最后剩下的数(约瑟夫环)  
051-构建乘积数组  

##题目和代码
1. 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

	jave
```
	public class Solution {
	    public boolean Find(int target, int [][] array) {
	        int rows = array.length;
	        int cols = array[0].length;
	        int i=rows-1,j=0;
	        while(i>=0 && j<cols){
	            if(target<array[i][j])
	                i--;
	            else if(target>array[i][j])
	                j++;
	            else
	                return true;
	        }
	        return false;
	    }
	}
```
	Python
```
# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        rows = len(array) - 1
        cols= len(array[0]) - 1
        i = rows
        j = 0
        while j<=cols and i>=0:
            if target<array[i][j]:
                i -= 1
            elif target>array[i][j]:
                j += 1
            else:
                return True
        return False
```
2. 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
	java
```
/*
问题1：替换字符串，是在原来的字符串上做替换，还是新开辟一个字符串做替换！
问题2：在当前字符串替换，怎么替换才更有效率（不考虑java里现有的replace方法）。
      从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下
      从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。
*/
public class Solution {
    public String replaceSpace(StringBuffer str) {
        int spacenum = 0;//spacenum为计算空格数
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)==' ')
                spacenum++;
        }
        int indexold = str.length()-1; //indexold为为替换前的str下标
        int newlength = str.length() + spacenum*2;//计算空格转换成%20之后的str长度
        int indexnew = newlength-1;//indexold为为把空格替换为%20后的str下标
        str.setLength(newlength);//使str的长度扩大到转换成%20之后的长度,防止下标越界
        for(;indexold>=0 && indexold<newlength;--indexold){ 
                if(str.charAt(indexold) == ' '){  //
                str.setCharAt(indexnew--, '0');
                str.setCharAt(indexnew--, '2');
                str.setCharAt(indexnew--, '%');
                }else{
                    str.setCharAt(indexnew--, str.charAt(indexold));
                }
        }
        return str.toString();
    }
}
```
	python
```
# -*- coding:utf-8 -*-
class Solution:
    # s 源字符串
    def replaceSpace(self, s):
        # write code here
        new_s = ''
        for j in s:
            if j == ' ':
                new_s=new_s + '%20'
            else:
                new_s=new_s + j
        return new_s
```
3. 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。  
	有三种思路，第一就是利用栈先入后出的特性完成，第二就是存下来然后进行数组翻转。
	第三是利用递归。
	java，递归思想，非常简洁
```
public class Solution {
    ArrayList<Integer> arrayList=new ArrayList<Integer>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if(listNode!=null){
            this.printListFromTailToHead(listNode.next);
            arrayList.add(listNode.val);
        }
        return arrayList;
    }
}  
```
	栈
```
import java.util.ArrayList;
import java.util.Stack;
public class Solution {
	public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        Stack<Integer> stack=new Stack<Integer>();
        while(listNode!=null){
            stack.push(listNode.val);
            listNode=listNode.next;     
        }
        
        ArrayList<Integer> list=new ArrayList<Integer>();
        while(!stack.isEmpty()){
            list.add(stack.pop());
        }
        return list;
    }
}
```
	Python,简单列表保存
```
def printListFromTailToHead(self, listNode):  
# write code here 
	res=[] 
	while listNode: 
		res.append(listNode.val) 
		listNode=listNode.next 
	return res[::-1] #逆序打印
```
	Python，递归  
```
class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode): 
        res=[] 
        def printListnode(listNode):
            if listNode: 
                printListnode(listNode.next)#先递归到最后一层 
                res.append(listNode.val)#添加值，退出函数，返回到上一层函数中的这行，继续添加值 
        printListnode(listNode) 
        return res
```
4. 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
5. 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
6. 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
7. 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39 

